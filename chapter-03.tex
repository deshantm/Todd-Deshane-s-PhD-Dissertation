%  chapter-03.tex

\chapter{Architecture}

In this chapter, we look at the architectural design our Rapid Recovery Desktop system. In order to place this work in the proper context, we first describe the scope, threat model, and assumptions of this work in section \ref{sec:scope}. Next, we explain the design decision involved in our architecture that is built on top virtualization, how this architecture fits with our threat model, and take a more detailed look at the structure of the trusted computing base. Then, we describe the design of virtual appliances, virtual machine contracts, and their recommended use with our Rapid Recovery Desktop system. We then describe the architecture of our virtualization security framework, called OSCKAR. Finally, we consider the architecture of our Rapid Recovery Desktop system, first from a file system perspective and then from a network perspective.

\section{Design Principles}
\label{sec:scope}

This dissertation makes use of a variety of technologies and concepts. In short, we use paravirtualization and hardware-assisted virtualization of hardware (platform) virtual machines, along with network file servers and software virtual switches, to provide support for the principle of least privilege, access control, and isolation on end-user desktop systems using open source technologies.

\subsection{Virtualization Scope}

Our system uses two of the most common types of platform virtualization, namely paravirtulization and hardware-assisted full virtualization. We make use paravirtulization since it provides high performance virtualization of open source operating systems, such as Linux. Paravirtualization can also make use of advances in hardware support for virtualization. Hardware-assisted virtualization is chosen because it provides efficient use of unmodified operating systems, which is helpful when working with proprietary guest operating systems, such as Microsoft Windows.

Hardware-assisted virtualization on commodity desktop systems has been commonly included since 2006, with the introduction of Intel VT~\cite{van_Doorn_2006}. Hardware vendors, such as AMD and Intel, and software vendors, such as Microsoft, VMware, Citrix, and Red Hat, have been cooperating in co-evolving the virtualization hardware and software to provide improved virtualization over time. This co-evolution of commodity hardware and software for virtualization is similar to how IBM has co-evolved thier z/VM software with the zSeries mainframe hardware since the 1960s.

\subsection{Security Scope}

There are various security techniques that could be employed to enhance the security properties of our system. The properties that our system design primarily applies are the principle of least privilege, access control, and isolation. We choose to focus specifically on these security techniques since they get at the root of the problem that this dissertation attempts to solve, the problem of too much access and not enough isolation of applications.

\subsection{Environment Scope}

With our system, we also choose to support desktop systems as a priority, but consider application of our system to mobile devices (such as smart phones and tablets), server-class systems (including public, private, and hybrid cloud environments), web-based environments, thin client setups, and virtual desktops (also known as desktop virtualization or virtual desktop infrastructure (VDI)) to be important and natural extensions of this work. We consider detailed analysis of these other systems and environments outside the scope of this dissertation, although we describe the applicability to other environments in the future work section of Chapter 6.

\subsection{Open Source and Open Standards}

We considered various virtualization and security technologies during the course of designing and implementing our prototype. Specifically, we try to incorporate technologies that are open source and that follow open standards. Open source technologies are generally better for distribution, extensibility, modifiability, inspection, and promoting collaboration than proprietary technologies~\cite{ben-yehuda_osr_2008}. Technologies that follow open standards promote interoperability among other products, are more deployable in practice, and encourage collaboration among developers. Simply using open source and open standards does not necessarily lead to these benefits~\cite{crosby_blog_interoperability_2010,gigaom_blog_2010}, but we believe that they are a good first step.

Although our solution focuses on open source and open standards, proprietary technologies can often be interchanged with open source components. We do understand there are instances where vendors need to make use of proprietary technologies and therefore we make it possible for proprietary components to be supported in our system. We describe our overall design, including the decisions that allow elements of the system to be interchangeable, in Chapter 3.

\subsection{Threat Model and Assumptions}

The virtual machine monitor (hypervisor) is part of the trusted computing base (TCB) and is intended to be a small, simple software layer and it is argued that since the hypervisor is able to be made more secure than a traditional operating system. In practice however, the hypervisor typically requires a management domain, which is also part of the TCB. Therefore, it is not safe to assume that the hypervisor is not able to be compromised by an attacker. However, as mentioned in section \ref{sec:mac}, it is unlikely that malware would be able to break out of the virtual appliance and turn off our contract system unless it was somehow able to subvert the virtual machine by, for example, breaking out of the VM and into the hypervisor or breaking into a component of our trusted computing base. At the end of this chapter, we further suggest techniques to harden the overall system. We consider hypervisor security and its formal or cryptographic verification to be outside the scope of this work. So, although attacks against the hypervisor are still of some concern, we defer a detailed look at this problem to other research and future work.

We assume that several service VMs are part of the TCB and that we have taken reasonable measures to secure and isolate them from direct attack. In particularly, we include an administrative VM for basic VM management, a FS-VM for serving user data on a internal virtual network, and a NET-VM for managing the internal and external networks. We note that the administrative VM, FS-VM, and NET-VM could all be contained within a single VM (or included in the base operating system), but we recommend separating them to provide better isolation, modularity, and flexibility to the overall system. Finally, all VMs not included in the TCB are considered untrusted and could fall under full control of an attacker (detecting and recovering from this scenario is a fundamental goal of this work).

We make a conscious choice to support both Windows and Linux guest operating systems, but also do not make design decisions that would limit the possibility of supporting other guest operating systems.  We also choose to focus our support and testing on open source hypervisor solutions, but this is not a fundamental requirement.

\section{Virtualization}

We chose to build our architecture using virtualization since it allows us to fundamentally change the security threat model and structure of the trusted computing base. Our threat model revolves around protecting user data and allowing the user to be in control of their system, even in the face of attack. At the same time, we give the user reasonable recovery methods, so they are not forced to chose between losing their personal data and recovering their system to a usable state.

Virtualization also gives us a unique opportunity to restructure the trusted computing base of a desktop system. First, since a virtualization system provides a rich set of isolation properties, it can be used to effectively isolate a user's personal data. At the same time, a guest VM can be provided with a network file server mount point to give the user and applications the proper access to the data. Specifically, our FS-VM is a special network file server, which, using virtualization and virtual networking, is isolated and protected from attacks from both external malicious entities and internal services or applications that have been infected by malware. Next, placing applications into virtual appliances significantly reduces the threat they pose on user data, other applications, and the overall system. Also, since virtualization gives us the ability to easily and efficiently restore a virtual appliance to a known good state, we are able to restore an application to a working state in response to either a bad upgrade or a malware infestation. Better still, since the user's personal data is stored in the FS-VM, it is not lost in the virtual appliance recovery process.

Recall that virtual appliances are not in the trusted computing base and are considered untrusted. A virtual appliance is required to have a contract associated with it that allows the appliance access to precisely the privileges it needs. For example, it can have access to specific mount points on the FS-VM or perhaps none at all. Also, it may need access to only the external network or it might not need a network connection at all. Further, external network access can be limited to certain types of incoming or outgoing data. A diagram of this setup is shown if Figure \ref{fig:NetworkArchitectureSimplified}, we will extend this figure and explain it in more detail in section \ref{sec:NetworkArchitecture}.

\begin{figure}[tbp]
\begin{centering}
\rotcaption{The architecture of our Rapid Recovery Desktop from a simplified network view.}
\label{fig:NetworkArchitectureSimplified}
\includegraphics[scale=0.9,angle=90]{figs/NetworkArchitectureSimplified}
\end{centering} 
\end{figure}


With virtualization, we are also able to change the trusted computing base of the networking of the system. As needed, we are able to create a large number of isolated network segments within the same physical system. Based on our threat model, it is important that we place our FS-VM on a virtual network segment that is not directly accessible from the outside Internet. In other words, attackers must make two successful exploits in order to gain privileged access to user data. We note that we are not arguing that an attack is not possible, but simply that an attack is made fundamentally more difficult with our architecture.

First, the attackers would need to compromise a virtual appliance that has been given access to the both the external network and some data on the FS-VM. Note that not all types of appliances need access to the external network, many appliances do not need access to the user's personal data, and some appliances (for example, local games) do not need access to the external network nor the user's personal data. Second, attackers would then need to use their position within the virtual appliance to make a successful exploit of the highly protected and secured FS-VM. Only if the attackers were able to accomplish both of those exploits, would they be able to gain privileged access to the user's personal data. However, getting the data out without being detected and blocked would be the attackers' next challenge. A closer look at the virtual network infrastructure, described next, shows why that task is also challenging.

As mentioned, since we are using virtualization, we can create a virtual network, which is built on a set of virtual switches that use an explicit allow and default deny policy to govern network accesses. The actual management of the switches is handled by our NET-VM component. This structure provides a layer of network defense, both from the outside Internet and the virtual appliances and other enforcement elements contained within the physical system, that significantly reduces the traditional attack vectors of malware and botnets. Malware that gains administrative access to a system will often first turn off network security systems, such as firewalls, anti-virus software, and intrusion detection systems. However, with the protection provided with our virtual switch network layer, turning off these defenses within the virtual appliance does not give the virtual appliance (nor the malware) any new access, since the network access policy is enforced from outside of the virtual appliance. 

Based on this virtual network layer, we turn back briefly to the attackers that have successful made two exploits to get to the user's data on the FS-VM. The FS-VM has no need to make outgoing connections (thus denied to do so by default), so even though the attackers are able to take control of the FS-VM and even to gain administrative access on it, they are unable to get it out of the system. The attackers only real hope is to find a lower level attack in the TCP/IP stack that could be used to exploit the NET-VM, then to change the networking policy to allow the FS-VM to connect out to the Internet. Note that making the first two exploits was unlikely in itself, further realizing the contraining environment and successfully making an exploit against it is much less likely. Defending against lower level attacks, such as those against the TCP/IP stack, are outside the scope of this dissertation. We will describe the various types of malware behaviors and the correpsonding responses of our Rapid Recovery Desktop system in Chapter 5 on evaluation.

\section{Virtual Appliances}

A Virtual appliance, as described in section \ref{VirtualAppliances}, contains one or more applications that are logically grouped into a virtual machine based on their network and data access needs. Notice that our definition of a virtual appliance is more specific than the traditional definition (any set of software installed within a virtual machine), so that our virtual appliances can be characterized by a single contract that is as specific as possible and is integrated cleanly into the Rapid Recovery Desktop system proposed in this dissertation. 

Our Rapid Recovery Desktop system can be configured in a variety of ways. At one extreme, our system could be configured as a single whole desktop virtual appliance that contains all of the user's applications in it. Even in this most simple configuration, security benefits can be realized.  At the other extreme, each application could be installed in its own virtual appliance. This configuration is not yet feasible due to current hardware and usability limitations. However, this type of configuration is something that we consider an important area of future work. In between the two extremes, we find our current recommended configuration, which is able to be set up on a wide variety of hardware and provides better security benefits at a small cost in terms of performance and complexity. Figure \ref{fig:VirtualApplianceDecomposition} shows the progression from a single whole desktop virtual appliance to each application in its own virtual appliance.

\begin{figure}[tbp]
\begin{centering}
\rotcaption{The Progression of Virtual Appliance Decomposition}
\label{fig:VirtualApplianceDecomposition}
\includegraphics[scale=1.0,angle=90]{figs/VirtualApplianceDecomposition}
\end{centering}
\end{figure}

There are many sites that offer pre-built virtual appliances for various virtualization platforms~\cite{vmware_appliances_website, rPath_website,  stacklet_website, virtual_appliances_website,  jumpbox_website}. The virtual appliances downloaded from these website could be used directly in the first whole desktop appliance case, but applying tight contracts and grouping applications based on data access needs would be even better. In this section, we will describe some specific examples of the types of virtual appliances that we recommend using with our Rapid Recovery Desktop system. We will also describe how virtual appliances can benefit from checkpoint, rollback, and the ability to protect user data in the FS-VM, even without the use of tight contracts.

\subsection{Whole Desktop in a Single Appliance}

A simple configuration of our Rapid Recovery Desktop system would be to simply move a user's complete desktop into a virtual appliance and configure it with a somewhat relaxed contract. This would allow users to have a nearly identical look and feel of their current system, but with some added security benefits. Specifically, some simple network contract rules, such as not allowing any incoming connections (or clearly specifying incoming flows to allow), could be added and would provide significantly more protection than is commonly seen in practice today. More specifically, even if attacker gained root access to the system and disabled the firewall on the operating system running in the virtual appliance, the network rules would still provide protection, since enforcement takes place outside of the virtual appliance. This defense alone would likely deter many would-be attackers from extending their control over the system. For example, the attacker would not be able to easily make the compromised system part of a botnet, since it is not able to have access to an easy mechanism, such as an open port, to issue botnet commands to the virtual appliance. Notice that even with this simple case (moving a user's existing system, as is, into a virtual appliance and applying basic networking rules at the virtual network layer), we have significantly changed the playing field for attackers.

A next simple step to provide more protection and recovery to this simple configuration would be to move common data types, such as documents, photos, and any other files that are considered especially valuable to the user to the FS-VM and mount those files over the internal virtual network. This would allow for a more clear backup strategy. Specifically, backing up the FS-VM would backup files that are considered important to the user. Also, by capturing checkpoints of the virtual appliance, the full system could be easily rolled back to a known-good working state. Notice that this is a significant improvement over the alternative of rolling back a full system on a traditional desktop, since the user data would need to be backed up and restored manually by a user. It is also often more helpful and much more predictable than simply restoring only system files, as is done with a traditional restore facility, such as Windows System Restore.

The alternatives, such as Windows System Restore, and full systems backups with tools like Clonezilla, and reset facilities such as Deep Freeze were discussed in related work. However, it is important to reiterate that the design of our system is complementary to having good backups, since the system only helps to make better backups and doesn't explicitly make backups of FS-VM data.  However, it does allow a user or administrator to create different backup strategies for user data and system data. Having mechanisms to backup the FS-VM could be enabled and are an area of future work. Also, other aspects of the design of our system make fine-grained restore of specific appliances possible. This aspect of the design is demonstrated by our recommended Rapid Recovery Desktop configuration option, described next.

\subsection{Grouping Applications Based on Access Needs}

The currently recommended way to configure our Rapid Recovery Desktop system is to decompose the single whole virtual desktop virtual appliance into a set of virtual appliances that are as distinct as possible in their data and network access needs. For example, we recommend grouping applications that have similar data access needs and that may be used together to accomplish tasks. Grouping together applications such as browser-based applications and other internet-related programs, such as instant messengers, can be a good idea, since they all need a connection to the Internet and are likely to have fewer and similar access needs. Users will likely share similar types of information over various Internet-based applications. So, granting proper access to the types of files that they share over the Internet are likely to be similar. 

Other applications that make sense to group are applications that don't need any network access, such as many games and other personal-only programs, such as a diary application. In other words, anything that is not likely to be shared over the Internet with others. Highly sensitive applications, such as financial software, can be viewed similarly and can be grouped together, since this type of application needs to be protected well and should not need much, if any, data or network access needs. Any data that these sensitive applications would need to share with other remote entities or other appliances should be protected by contract rules. For example, if data from a financial application is needed by a document appliance for annual reports, then strict contract rules should allow for that specific access. Another scenario that a sensitive application, such as a financial application, would be a case where it needs temporary access to the Internet in order to get updates or to transfer information to or from a banking website. Handling such scenarios may require more complicated contracts or require special ways of doing things. More advanced contracts are an area of future work. Requiring extra effort on the user or appliance designer's part, although not desired, could be both acceptable and beneficial, as long as the users can clearly understand the security benefits gained.

\paragraph{Server Software}

Server software, although not necessarily common among desktop users, could become a lot easier to use and more secure when deployed as a virtual appliance in our Rapid Recovery Desktop model. Users could enjoy the benefit of having their own website or content management system without having to do much administration. Pre-packaged server appliances are common~\cite{vmware_appliances_website, rPath_website, stacklet_website, virtual_appliances_website, jumpbox_website}. Also server-based virtual appliances have well-known usage patterns and so writing virtual appliance contracts for web servers, database servers, and the like, is a much more straight forward process than trying to predict the usage patterns of desktop users. Further, breaking up the web server and database server components becomes easier and more attractive when it is integrated into the Rapid Recovery Desktop system architecture. For example, the database server could be accessed on a private network that is only accessible by the web server and only in very specify ways, such as only over a specific port. 

Let's take one example of a server-based virtual appliance, specifically a web server appliance. It would make sense to mount the web server's content to the FS-VM and grant read-only access to the web server appliance, so that even if the web server is compromised, the web site content is protected in the FS-VM. This method also allows for a more clear backup strategy and allows the web server appliance to be easily recovered. Write access to the web site data could be given to the appliance that handles creation and editing of that web data. In the case of content management systems, which often write their own data, contract rules that restrict the amount and type of data could be written to provide more protection than is typically bundled with a typical content management system.

Web server logs, unlike desktop operating system logs, can often be much more valuable from a user's perceptive, since measuring the usage of the server and types of visitors can be helpful. So, storing these types of logs in the FS-VM might be beneficial. Operating systems logs, while useful to system administrators, are not likely to be useful to the typically user. Appliances could be designed to identify groups of files (directories) that could be managed by or backed-up to the FS-VM. Thus, allowing users of our system can be smarter about the type of data that they consider to be valuable enough to store in the FS-VM, backup more frequently and protect more carefully.

We have described examples of virtual appliance design here, while leaving out many of the details of actual implementation. In the next chapter (Chapter 4 Implementation), we show more of the actual implementation details of a Rapid Recovery Desktop system that utilizes the design principles described in this chapter.

\subsection{One Application Per Virtual Appliance}

Another step would be to put each application into its own appliance. Web-based email, such as Gmail, Hotmail, or Yahoo! mail would be best grouped in the browser appliance, as these web-based applications would have very similar access needs. For example, web-based email would need network access to make outgoing web connections, the ability to save attachments (downloads), and the ability to read documents (such as photos) to be attached to emails. However, it is likely that putting desktop email clients applications in their own virtual appliance makes sense, since there are many drive-by download type attacks on browsers that try to secretly install a small mail server to send spam. The problem with combining desktop email clients with the browser appliance is that it would allow the possibility for that appliance to send spam email. Even with rate-limiting, it wouldn't be protected against more stealthy attackers that are willing to send spam email at a slower rate. So, having a separate email appliance makes contract rules simpler and provides a better level of isolation among applications. Having one application per virtual appliance is also better because it allows the appliance designer to have full control and, in some sense, ownership of the contract (although users would still have the ability to modify it to match their particular needs).

Similarly, placing other appliances in their own virtual appliances would allow for tighter contracts and stronger isolation, but the limiting factor is the hardware resources available. To better manage some of the resource limitations, we have started some design and proof of concept construction on an application segregation tool, called Appify, that will run ``appified'' applications in their own VM to provide careful management and fine-grained segregation of applications. Similarly, as we will discuss in future work, we have started to design ways to better integrate user interface mechanisms (such as drag-and-drop and open dialogs) with our Rapid Recovery Desktop system to provide a user-friendly way for applications to share data.

\section{Virtual Machine Contracts}

Virtual machine contracts (VMCs) are the glue that hold the system together. As described in section \ref{sec:VirtualMachineContracts}, VMCs are starting to gain some research and standards-based traction\cite{virtual_machine_contract_ICAC09 }, but are not yet widely deployed in practice. For example, methods to assign more advanced network and data access needs within a VMC are not yet available. In this dissertation, we have designed and implemented a basic and generic virtual machine contract system that can be extended to support a wide variety of constraints on virtual appliances. The detailed design of VMCs is best addressed in the context of our virtualization security framework, which is described in the next section. Implementation details are then presented in Chapter 4.

\section{Virtualization Security Framework}

To complement our decision to use virtualization, virtual appliances, and VMCs as the basis of our architecture, we needed to provide a communication mechanism for distributing the contracts to the various enforcement elements (for example, the FS-VM and NET-VM). For this purpose, we implemented a virtualization security framework, called OSCKAR. OSCKAR is structured as a message bus and policy management system that contains a set of interfaces that are used to interact with core components (for example, a VMM interface interacts with the hypervisor), enforcement elements (for example, an FS-VM interface interacts with the FS-VM), and control elements (for example, a Rapid Recovery Desktop interface interacts with the Rapid Recovery Desktop control component). A Rapid Recovery Desktop interface is the set of library functions exposed and registered with OSCKAR and the Rapid Recovery Desktop component is the front-end environment (including the desktop window environment) that is interacted with through the Rapid Recovery Desktop interface.

Note that OSCKAR only needs to contain core interfaces to function. It does not need to contain enforcement or control components to provide some basic functionality. For example, since the VMM interface is considered a core component, it must exist in OSCKAR's core functionality, which can then be used directly by a developer that includes the OSCKAR framework in their application. OSCKAR is designed to work with a variety of enforcement elements and control components. In this dissertation, we focus specifically on two example enforcement elements, namely a NET-VM and FS-VM. We also present two examples of control components, namely the KIOSKAR control element (a simple virtual machine kiosk, described next) and the Rapid Recovery Desktop control element used to drive the functionality of the system in this dissertation.

The recommended use of the OSCKAR framework is for a product developer to extend OSCKAR to include a control interface that is used to interact with a control element that they create. A product that we developed to demonstrate this use case was a kiosk application, called KIOSCKAR, that allowed users to select and load a virtual machine from a graphical menu. The virtual machines available in the menu needed to be pre-loaded into the system by an administrator. To test OSCKAR's functionality, we created VMCs to be associated with each of the virtual machines. The virtual machines could be full operating system virtual appliances or special-purpose virtual appliances.

%would also like to somehow mention the statelessness of a kiosk and how we implemented it %with copy on write disks to store only temporary state, but explaining all the details of why % andhow makes it go too far off topic, maybe that will fit in another part of the dissertation    % better.

For our implementation of the KIOSKCAR product, we created a control interface library that connected to the OSCKAR core components (Event Chat, Policy Manager, and VMM) to provide high-level KIOSCKAR functions. A set of control elements (a command line version, a graphical user interface, and web application) were then created that interacted with the KIOSCKAR control interface. The command line control element allowed users to type a number to load a particular virtual machine, the graphical user interface control element version of the kiosk presented in graphical menu for user to click to select the virtual machine, and the web-based version of the kiosk presented a web-page for users to click to use a particular virtual machine. The web-based version of the kiosk was developed by a sophomore communications major as a Clarkson Open Source Institute (COSI) project. This demonstrates that the the high-level functionality of the KIOSCKAR control interface is reusable by other developers to create distinct user interfaces.

A more advanced product, demonstrated in this dissertation in the form of our Rapid Recovery Desktop system, makes use of all three types of interfaces, core, control, and enforcement. The core interfaces are the same as with KIOSCKAR, namely Event Chat, Policy Manager, and VMM. Our Rapid Recovery Desktop system uses the core VMM interfaces to interact with the hypervisor, it creates control interfaces to provide the basic Rapid Recovery Desktop front-end functions, and it creates enforcement interfaces to interact with the enforcement elements (specifically the FS-VM and NET-VM).

\subsection{Virtualization Security Framework and Virtual Machine Contracts}
With that high level description of the OSCKAR security framework, we now proceed with the design details of OSCKAR and describe how to associate a VMC with a virtual appliance using our OSCKAR framework. The implementation details of OSCKAR and specific examples based on real-world virtual appliances and contracts are show in Chapter 4. The architecture of OSCKAR is shown in Figure \ref{fig:OSCKAR}.

% http://www.ee.tamu.edu/~tex/manual/node37.html
\begin{figure}[tbp]
\begin{centering}
\rotcaption{The Achitecture of our OSCKAR Virtualization Security Framework}
\label{fig:OSCKAR}
\includegraphics[scale=1.0,angle=90]{figs/OSCKARArchitecture}
\end{centering}
\end{figure}

At the heart of the OSCKAR architecture is a EventPolicy core, which is composed of two main components, an Event Chat message bus and a Policy Manager security daemon. 

The Event Chat component is a simple message bus and functions much like an Internet Relay Chat (IRC) server, in that it provides for authentication and communication among a Policy Manager (the trusted operator) and the various control and enforcement elements. The communication over the message bus is event-driven. Event Chat is designed to be simple, fast, and reliable. Our implementation of Event Chat uses a standard TCP socket interface, is multi-threaded, and is designed to receive a variety of input, even invalid input, and not crash.

The Policy Manager component is the security daemon. It implements the functionality of local and global policy, so that an administrator could have a global policy that would override a local contract policy. For instance, the administrator might want to disallow BitTorrent globally, even if a virtual appliance contract would otherwise allow it. The Policy Manger can also be configured to raise events in specific ways in order to better control operational logic. For example, when importing a contract, a portion of the contract may be used for building the disk image for the virtual appliance, this would be need to be sent to the builder interface before other steps, such as starting the VM, and so this type of sequential or dependency-based functionality is built into the configuration language of the Policy Manager.

At a high level, the EventPolicy core is designed so that it can also be used in other environments, such as event and policy management for home automation, and is not limited to use with virtualization. Our OSCKAR core component however is specifically designed for use with virtualization. Thus, we include a VMM interface inside of OSCKAR as a core component that interacts directly with the underlying hypervisor in an appropriate manner on behalf of OSCAR core. The VMM interface includes functionality to create, start, pause, suspend, restart, stop, and destory VMs.

In order to create a product, such as our Rapid Recovery Desktop, one or more control elements are necessary. Control elements are used to drive the functionality of the system. For instance, a control element for the Rapid Recovery Desktop needs to pass the virtual machine contract to OSCKAR, so that when the user wants to start the virtual appliance, the control element can instruct OSCKAR to start it. The same, or a distinct, control element could then be used to show the interface of the virtual appliance to the user. The interaction of control elements and OSCKAR is designed in a general manner, specific examples of the interactions that we developed are described in section \ref{sec:implementation:OSCKAR}.

Next, a product needs zero or more enforcement elements. Products can in fact exist without an enforcement element, As an example, consider our kiosk (the KIOSCKAR product described above), it booted virtual machines based on temporary stateless disks (changes to a copy-on-write disk image were destroyed when the virtual machine was shutdown) and did not require user data to be saved, so an FS-VM component was not necessarily. For security purposes, a NET-VM component could have been used, but putting the virtual machines behind a software network address translation (NAT) router and destroying state on every shutdown was sufficient security for an initial release. This is not to say that our kiosk product could not use enforcement elements, but adding enforcement elements, especially those used in our Rapid Recovery Desktop system, transforms the kiosk into somewhat of a different product. As the virtual machines that the kiosk boots become more like virtual appliances are protected by VMCs the virtual appliances become more manageable and the kiosk is tranformed into a product more like a Rapid Recovery Desktop system with a kiosk front-end. An equivalent system would be to create a kiosk or web-based control element and interface for our Rapid Recovery Desktop system. This would be an interesting area of future work. 

The additional functionality that enforcement elements can provide make them an attractive option. For instance, an enforcement element for the Rapid Recovery Desktop system is the FS-VM component, which is used to allow specific virtual appliances, as specified in their contracts, to attach to specific data stores in order to provide file access control of user data. Similarly, our NET-VM component provides network access control for virtual appliances. Other enforcement elements can be added as needed and can then be used by virtual appliances by specifying the use of the enforcement element and rules in the virtual machine contract.

Since the communication over the Event Chat message bus is event-driven, control and enforcement elements simply register for and raise events that are filtered through the Policy Manger security daemon and handled by the appropriate elements. For example, the FS-VM in our Rapid Recovery Desktop product registers for the event ``mount\_documents'', then when a virtual appliance, such as a document editor, has a FS-VM rule that specifies a need to ``mount\_documents'', the request is passed through the Policy Manager component, to the FS-VM so that the processing can take place. Further, we require other FS-VM contract options, such as the access type (read, write, append, etc.) and allow other options, such as the rate of access, to be optional. In this manner, the FS-VM designer has the flexibility to build an FS-VM that is as powerful and flexible as they choose. We will further discuss other details of our control and enforcement elements in Chapter 4 on Implementation.

The control and enforcement elements are generic by design to allow their designers to provide as much or as little functionality as they choose and in the manner that they choose. For example, control and enforcement elements could be proprietary components that provide a similar service as our Rapid Recovery control element, FS-VM interface component, or NET-VM interface component. Control and enforcement elements could also be external physical components, such as a stand-alone firewall hardware appliance, that exists somewhere on the network. This flexible OSCKAR design is an example of providing an open source and open standards framework that can be built upon in innovative and competitive ways.

Finally, it is important to note that the OSCKAR virtualization security framework can be used for a variety of other products, not just our Rapid Recovery Desktop system. For example, as previously mentioned, during early development of Rapid Recovery Desktop, we developed a kiosk system, which we named KIOSCKAR. KIOSCKAR allows users to select from a menu of various operating systems, which are transparently run in a VM, and are able to use without needing to restart the computer. In other words, it is a operating system zoo running on a single computer. KIOSKCAR is open source and is being tested on some of the computers in the applied computing labs at Clarkson.


Other products that are either being worked on include an application segregation tool, called Appify, that will run ``appified'' applications in their own VM to provide for even finer-grained segregation of applications. Also, other ideas are that we could use OSCKAR to create a web-based VM administration tool, or a Virtual Desktop Infrastructure (VDI) management tool to provide desktop virtualization in the form of thin clients to a collection of computers, such as a classroom.

\section{File System Level Architecture}

In order to protect the user's personal data, portions of the file systems of the virtual appliances used in our Rapid Recovery Desktop system are mounted over a network file server (specifically our FS-VM). This allows us to restrict both the subset of data a virtual machine can access as well its access rights to that data. The portions of the user's data store that are mounted from the FS-VM are appliance-specific. Figure \ref{fig:FS-VM-Architecture} shows a view of our system from a file system view. It shows how a browser appliance would  mount the Downloads folder (typically \$HOME/Downloads in Linux and \$HOME/My Documents/Downloads in Windows) as read/write. Browser-specific settings and plugins could also be mounted on the FS-VM, if desired. A typical user may want to upload photos using their browser appliance, so the photos directory (typically \$HOME/Pictures in Linux and \$HOME/My Documents/My Pictures in Windows) could be mounted read-only. These mount rules and mount points would either need to be set up ahead of time by the virtual appliance designer. The appliance designer could also give the user a way to automatically or manually configure mount points and access permissions. A photo editing appliance would need to mount the photos directory read/write, so that it could make modifications to the photos. This separation of privilege protects the user's photos from being corrupted by malware in the browser appliance. Having the data stored in the FS-VM also allows restoring the browser appliance to a known good state and leaving the user's data intact. The browser appliance would simply mount the data stored on the FS-VM on boot.

\begin{figure}[tbp]
\begin{centering}
\rotcaption{The architecture of our Rapid Recovery Desktop from a file system view}
\label{fig:FS-VM-Architecture}
\includegraphics[scale=0.9,angle=90]{figs/FS-VM-Architecture}
\end{centering} 
\end{figure}


Although we do not focus on enhancements to the FS-VM in this dissertation , alternative FS-VM implementation could support a richer set of mount point permissions that allow ``write-rarely'' or ``read-some'' semantics as was shown in\cite{rapid_recovery_paper_05}. Specifically, an FS-VM designer could add read and write rate-limiting capability to each mount point in addition to full read or write privileges. Using this design, one can specify the amount of data that can be read or written per unit of time. For example, a mount point could be classified as reading at most 1\% of the data under the mount point in 1 hour. Such a rule could prevent malicious code from rapidly scanning the user's complete data store. These read and write limits are just one example of a richer set of mount point permissions that can be used to help protect against attack. Append-only permissions (i.e. the ability to add new files, but not modify or delete existing files) could be used to prevent removal or corruption of existing data. (SELinux has support for append-only file systems of this type\cite{smalley_2001}. For example, a directory containing photos could be mounted append-only in one virtual machine appliance allowing it to add photos, but not to delete existing photos. Another example would be restricting the size or file extension of files that are created (e.g. no .exe or files marked as executable files).

\section{Network Level Architecture}
\label{sec:NetworkArchitecture}

There are several approaches to virtual networking, which include a variety of software networking devices (e.g. virtual bridges or switches), combination solutions that use virtualization-aware network hardware and software virtual switches that cooperate with that hardware, and software networking devices that offload virtual networking to standard physical network hardware with standard networking techniques. The differences in the various approaches distinguish between where enforcement elements reside. For instance some network hardware vendors think that more capabilities should be pushed into the hardware. Others argue that requiring new complicated switching devices that are virtualization-aware is the wrong approach. For more details on the alternatives in general, interested readers are referred to\cite{ovs_hotnets_2009, casado_hotnets_2008, cisco_nexus_website, vepa_2008, vntag_2008, vmware_vNetwork_Distributed_Switch_website}.

In this section, we describe the virtual network design of our system. We set up three virtual switches (vswitches), namely an external vswitch, an internal vswitch, and an OSCKAR management vswitch. The external vswitch is connected directly to the physical network through the main network interface card (NIC) of the host system. The internal vswitch provides an isolated private internal network with no direct link to the external vswitch. The OSCKAR management switch is a private network that the OSCKAR framework uses to communicate with control and enforcement elements. All of the vswitches are managed by a NET-VM component. This architecture is depicted in Figure \ref{fig:NetworkArchitecture}.

\begin{figure}[tbp]
\begin{centering}
\rotcaption{The architecture of our Rapid Recovery Desktop from a network view}
\label{fig:NetworkArchitecture}
\includegraphics[scale=0.9,angle=90]{figs/NetworkArchitecture}
\end{centering} 
\end{figure}

This network design provides for logical isolation of the enforcement components and various virtual appliances, each of which can have differing network and data access needs. The most isolated component, the FS-VM, is connected to the internal vswitch and is only accessible to virtual appliances that have specified in their contract to have access to specific mount points of the FS-VM. This implies that an attacker would need to first exploit a virtual appliance and also then the FS-VM in order to gain access to user data. This architectural design alone is a significant improvement from the current traditional operating system model.

Next, the isolation of the external vswitch and the internal vswitch allow for logically different virtual appliances to have only the network and data access they need and no more. For example, it may be the case that a browser appliance only needs access to the external network and doesn't need access to user data stored on the FS-VM. Similarly, a photo or document editing program may only need access to specific mount points (photos and documents respectively) and not need any external network access. Finally, it may be the case that an email appliance needs access to documents and photos to save and send attachments as well as an external internet connection in order to send and receive email.

Finally, a network virtual machine (NET-VM) component is used to manage all of the vswitches. The NET-VM component is only given access to connect over a secure channel to a virtual switch management utility running in the management domain. This configuration allows logical separation of the NET-VM to the rest of the system and, similar to the protection of the FS-VM, provides isolation from attacks that target the network infrastructure. The NET-VM component could further be isolated by giving it exclusive access to the physical network card, which it would then have the vswitches within itself and act as a driver domain for the other virtual appliances that need network access. Advanced configurations, such as making the NET-VM a driver domain, will be discussed in section \ref{sec:FutureWork}.

\subsection{Hardening the Overall System}

In this section, we discuss the basic design methodology of securing (or hardening) our trusted computing base. At a high level, we have enforcement elements, a virtualization security framework, a management domain and a hypervisor that are all considered part of our TCB. Recall that virtual appliances are not considered part of the TCB, but can benefit from general hardening strategies.

The basic hardening method that we employ is to keep things as simple as possible. For example, within the enforcement elements, such as the FS-VM, we remove all unnecesary services and keep the operating system to be as simple as secure as possible. This implies that no extra ports are open, a GUI is not installed if it is not needed, and modules are not loaded unless they are needed. We also suggest to use mandatory access control rules to protect the enforcement elements, both from the outside using a MAC embedded within the virtualization layer and within the VM itself using a standard MAC, such as SELinux or AppArmor.

Other strategies for hardening the system include using defense in depth and VM introspection techniques. Defense in depth means using a layered approach, for example by employing a firewall at the perimeter and also firewalls within. In practical terms, this means that the base system should use a firewall as well as the VMs within it. Further, to protect the security software within the VM itself we suggest the use of VM introspection techniques. The basic idea is to inspect the critical code and data (for example on disk and in memory) of the VM from the hypervisor. We have not yet deployed this technique, but research and practical implementation work in this area will be discussed in section \ref{sec:FutureWork}.

Finally, a key strategy that we employ to enhance the hardening is isolation. In particular isolating the various components onto their own network segments can reduce the surface area of attack. For example, the management domain and the virtualizaiton security framework can be isolated on their own isolated virtual network. A first pass implementation of this network architecture was described earlier in this chapter. In future work, we consider more advanced network control techniques, such as using a OpenFlow controller as the NET-VM component.

Now that we have described the design of our system, we move on to describing the implementation details in the next chapter.




